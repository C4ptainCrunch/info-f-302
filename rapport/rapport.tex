\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{fullpage}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{upgreek}
\usepackage{amsmath}

\title{
    Orthogonal Packing\\
    \small Projet d'informatique fondamentale - INFO-F-302
}
\author{
    Nikita \bsc{Marchant} et Romain \bsc{Fontaine}\\
    ULB BA3 2015-2016
}
\date{20 mai 2016}

\linespread{1.1}

\setlength{\parskip}{0.5em}

\begin{document}
\maketitle
\tableofcontents

\section{Introduction}

Nous définissons les symboles suivants :
\begin{itemize}
  \item $\mu(i) = (A(i), B(i))$ ou en 3D, $\mu(i) = (A(i), B(i), C(i))$
  \item $\beta_{i, x, y}$ : le fait que le rectangle $i$ contienne le point $(x, y)$ (ou en 3D, $\beta_{i, x, y, z}$ qui contient $(x, y, z)$)
  \item $\gamma_{i, x, y}$ : le fait que $\mu(i) = (x, y)$ ou en 3D, $\gamma_{i, x, y} \rightarrow \mu(i) = (x, y, z)$
  \item Dans la question sur les pivotages, $R(i)$ veut dire que le rectangle $i$ est pivoté, $\lnot R(i)$, qu'il n'est pas pivoté
\end{itemize}

\section{Questions}
\subsection{Écrire les contraintes que soit satisfaire $\mu$}

On peut commencer par énoncer en français les contraintes à respecter :
\begin{enumerate}
  \item Un rectangle ne peut être placé hors du grand rectangle
  \item Deux rectangles ne peuvent pas se superposer
  \item Le fait qu'un rectangle commence à une position implique que toutes les positions ``suivantes'' soient occupées par ce même rectangle
  \item Chaque rectangle doit être placé au moins une fois
  \item Chaque rectangle doit être placé au maximum une fois
\end{enumerate}
\vspace{1em}

On peut ensuite les formaliser mathématiquement :
\begin{enumerate}
  \item $\forall i \in k$ : $A(i) \geq 0$ et $B(i) \geq 0$ et $A(i) + \mathcal{X}(i) \leq n$ et $B(i) + \mathcal{Y}(i)\leq m$

  \item $\forall i,j \in k, i \neq j, \forall x \in [0,n], y \in [0,m] : \beta_{i, x, y} \rightarrow \lnot \beta_{j, x, y}$

  \item $
  \forall i \in k,
  \forall x \in [0, n - \mathcal{X}(i)] , y \in [0, m - \mathcal{Y}(i)],
    x' \in [0, \mathcal{X}(i)], y' \in [0, \mathcal{Y}(i)] : \gamma_{i, x, y} \rightarrow \beta_{i, x', y'}
  $

  \item $\forall i \in k, \exists x \in  [0, n - \mathcal{X}(i)], y \in [0, m - \mathcal{Y}(i)] : \gamma_{i, x, y}$

  \item $
  \forall i \in k,
  \forall x,x' \in [0, n - \mathcal{X}(i)],
  \forall y,y' \in [0, m - \mathcal{Y}(i)],
  x \neq x', y \neq y' :
  \gamma_{i, x, y} \rightarrow \lnot \gamma_{i, x', y'}
  $
\end{enumerate}

\subsection{Construire une formule $\Phi$ en FNC}
On commence par exprimer chaque contrainte de la question précédente en FNC :
\begin{enumerate}
  \item On remarque que la règle 1 est comprise dans la règle 3 grâce à un judicieux choix des bornes, nous n'en avons donc plus besoin.

  \item $
  \bigwedge_{i \in k} \bigwedge_{j \in k, i \neq j} \bigwedge_{x=0}^{n} \bigwedge_{y=0}^{m}
  \Big( (\lnot \beta_{i, x, y}) \lor \beta_{j, x, y} \Big)
  $

  \item $
  \bigwedge_{i \in k}
  \bigwedge_{x=0}^{n - \mathcal{X}(i)} \bigwedge_{y=0}^{m - \mathcal{Y}(i)}
  \bigwedge_{x'=0}^{\mathcal{X}(i)} \bigwedge_{y'=0}^{\mathcal{Y}(i)}
  \Big( (\lnot \gamma_{i, x, y}) \lor \beta_{i, x+x', y+y'} \Big)
  $

  \item $
  \bigwedge_{i \in k} \bigvee_{x=0}^{\mathcal{X}(i)} \bigvee_{y=0}^{\mathcal{Y}(i)} \gamma_{i, x, y}
  $

  \item $
  \bigwedge_{i \in k}
  \bigwedge_{x=0}^{n - \mathcal{X}(i)} \bigwedge_{y=0}^{m - \mathcal{Y}(i)}
  \bigwedge_{x'=0, x\neq x'}^{n - \mathcal{X}(i)} \bigwedge_{y'=0, y\neq y'}^{m - \mathcal{Y}(i)}
  \Big( (\lnot \gamma_{i, x, y}) \lor \lnot \gamma_{i, x', y'} \Big)
  $

\end{enumerate}
\vspace{1em}

La FNC complète est la conjonction des 4 formules ci dessus.

Cependant, nous pouvons omettre la 5ème contrainte. En effet, cela ne nous pose pas problème qu'un rectangle soit posé à plusieurs endroits en même temps. Il suffit que notre programme ne garde que la première position qui a été trouvée pour chaque rectangle et ne s'occupe pas des autres.

\subsection{Implémenter}

Implémenter et tester sur les exemples 1 et 2, et proposer éventuellement
d’autres exemples.

\subsection{Trouver le plus petit carré admettant une solution}

\paragraph{Méthode initiale} Premièrement, nous avons essayé d'implémenter une solution ne devant faire tourner qu'une seule fois le solveur SAT.
Pour cela, nous générons un problème comme ceci :

``Résoudre l'orthogonal packing dans un grand rectangle de largeur $n$ et le longueur $n$'' avec $n$ défini comme $max(\sum_{i \in k} \mathcal{X}(i), \sum_{i \in k} \mathcal{Y}(i))$.

Nous savons que ce problème est satisfaisable : il suffit d’empiler les rectangles les uns au dessus des autres.

Nous définissions $\pi_h$ comme le fait qu'il y aie une case qui est occupée par un rectangle et appartenant au carré de largeur $h$ mais pas au carré de largeur $h-1$ ou que $\pi_{h+1}$ soit vrai.
$$
  \Big(
    (\exists i \in k, x \in [0, n]: \beta_{i, x, h})
    \lor (\exists i \in k, y \in [0, n]: \beta_{i, h, y})
    \lor \pi_{h+1}
    \Big)
    \rightarrow \pi_h
$$

Cette implication peut être simplifiée par la somme de ces deux ci :
\begin{itemize}
  \item $\forall i \in k, x \in [0,n], y \in [0,n] :\beta_{i, x, y} \rightarrow \pi_{max(x,y)}$
  \item $\forall h \in [0, n]: \pi_h \rightarrow \pi_{h-1}$
\end{itemize}
\vspace{1em}


Il suffira ensuite de trouver $h$ le plus petit tel que $\lnot \pi_{h}$ pour savoir qu'il est possible de rentrer tous les rectangles dans un carré de côté $h$. Malheureusement, cette méthode nous donne uniquement un $h$ qui est satisfaisable et non pas le plus petit $h$ possible.

Pour minimiser ce $h$, nous pouvons utiliser MAX-SAT pour essayer de satisfaire le plus de contraintes $\lnot \pi_h$ (avec $h \in [0, n]$) possible. Cependant, il semble que la question ne demande pas d'utiliser MAX-SAT. Nous n'avons donc pas utilisé cette méthode.

\paragraph{Méthode retenue} Méthode que nous avons finalement retenue est la suivante :

Pour trouver le plus petit carré $R$ admettant une solution au problème, nous regardons d'abord si le carré de côté $n=\sqrt{a}$, $a$ étant la somme des aires des rectangles : $a = \sum_{i \in k} \mathcal{X}(i) \cdot \mathcal{Y}(i)$ est satisfaisable.

Si le carré de côté $\sqrt{a}$ satisfait le problème, nous nous arrêtons là, nous avons trouvé le plus petit carré possible (plus petit, son aire serait inférieure à la somme des aires des rectangles).

Si il ne le satisfait pas, nous doublons $n$ jusqu'à ce qu'il le satisfasse. A ce moment là, nous avons une borne inférieure ($\frac{n}{2}$) et supérieure ($n$) pour la taille minimale du côté du carré.

A partir de ces deux bornes, nous pouvons faire une recherche dichotomique pour rapprocher celles-ci jusqu'à ce qu'elles soient identiques.

\subsection{Étant donné $n$, trouver la dimension du plus petit carré contenant les carrés $\{r_1 \ldots r_n \}$}

Nous pouvons considérer que ce problème est un cas particulier du précédent et par conséquent le résoudre de la même manière.

\subsection{Ajouter une 3ème dimension}
Nous pouvons ré-utiliser les mêmes contraintes que pour la question 1 en rajoutant une dimension :

\begin{enumerate}
  \item $\forall i,j \in k, i \neq j, \forall x \in [0,n], y \in [0,m], z \in [0,o] : \beta_{i, x, y, z} \rightarrow \lnot \beta_{j, x, y, z}$

  \item $
  \forall i \in k,
  \forall x \in [0, n - \mathcal{X}(i)] , y \in [0, m - \mathcal{Y}(i)], z \in [0, o - \mathcal{Z}(i)],
    x' \in [0, \mathcal{X}(i)], y' \in [0, \mathcal{Y}(i)], z' \in [0, \mathcal{Z}(i)]  :
    \gamma_{i, x, y, z} \rightarrow \beta_{i, x', y', z'}
  $

  \item $\forall i \in k, \exists x \in  [0, n - \mathcal{X}(i)], y \in [0, m - \mathcal{Y}(i)], z \in [0, o - \mathcal{Z}(i)] :
  \gamma_{i, x, y, z}$
\end{enumerate}
\vspace{1em}

Ce qui nous donne en FNC :

\begin{enumerate}
  \item $
  \bigwedge_{i \in k} \bigwedge_{j \in k, i \neq j}
  \bigwedge_{x=0}^{n} \bigwedge_{y=0}^{m} \bigwedge_{z=0}^{o}
  \Big( (\lnot \beta_{i, x, y, z}) \lor \beta_{j, x, y, z} \Big)
  $

  \item $
  \bigwedge_{i \in k}
  \bigwedge_{x=0}^{n - \mathcal{X}(i)} \bigwedge_{y=0}^{m - \mathcal{Y}(i)} \bigwedge_{z=0}^{o - \mathcal{Z}(i)}
  \bigwedge_{x'=0}^{\mathcal{X}(i)} \bigwedge_{y'=0}^{\mathcal{Y}(i)} \bigwedge_{z'=0}^{\mathcal{Z}(i)}
  \Big( (\lnot \gamma_{i, x, y, z}) \lor \beta_{i, x+x', y+y', z+z'} \Big)
  $

  \item $
  \bigwedge_{i \in k}
  \bigvee_{x=0}^{\mathcal{X}(i)} \bigvee_{y=0}^{\mathcal{Y}(i)} \bigvee_{z=0}^{\mathcal{Z}(i)}
  \gamma_{i, x, y, z}
  $
\end{enumerate}

\subsection{Empêcher un pavé de ``flotter''}

Pour empêcher un pavé de flotter, nous pouvons ajouter la contrainte suivante :

$$
\forall i \in k, \forall x \in [0, n], y \in [0, m], z \in [1, o] :
\exists j \in k \beta_{i, x, y, z} \rightarrow \beta_{j, x, y, z-1}
$$

Celle-ci peut se traduire en FNC comme ceci :

$$
\bigwedge_{i \in k}
  \bigwedge_{x=0}^{n} \bigwedge_{y=0}^{m} \bigwedge_{z=1}^{o}
  \Big[
  (\lnot \beta_{i, x, y, z}) \lor (\bigvee_{j \in k} \beta_{j, x, y, z-1})
  \Big]
$$

Nous aurons besoin de rajouter la 5ème règle qui avait été laissée de côté à la question 1. En effet, un pavé posé à deux endroits dont la deuxième occurrence est enlevée à l'output pourrait laisser un trou à la place et les couches du dessus pourraient ne pas être supportées.

\subsection{Pivotage}

Ici aussi, nous pouvons utiliser presque les mêmes contraintes que pour la question 1.

$$
\forall i \in k,
\forall x \in [0, n] , y \in [0, m],
x' \in [0, \mathcal{X}(i)], y' \in [0, \mathcal{Y}(i)] : C_1 \lor C_2
$$

$$
C_1 : \Big(
\gamma_{i, x, y} \land \lnot R(i)
\land (x + \mathcal{X}(i) \leq n)
\land (y + \mathcal{Y}(i) \leq m)
\Big)
\rightarrow \beta_{i, x + x', y + y'}
$$

$$
C_2 : \Big(
\gamma_{i, x, y} \land R(i)
\land (x + \mathcal{Y}(i) \leq n)
\land (y + \mathcal{X}(i) \leq m)
\Big)
\rightarrow \beta_{i, x + y', y + x'}
$$

En FNC :

$$
\bigwedge_{i \in k}
\bigwedge_{x=0}^{n} \bigwedge_{y=0}^{m}
\bigwedge_{x'=0}^{\mathcal{X}(i)} \bigwedge_{y'=0}^{\mathcal{Y}(i)} C_1 \lor C_2
$$

$$
C_1 :
\lnot \gamma_{i, x, y} \lor R(i)
\lor \lnot (x + \mathcal{X}(i) \leq n)
\lor \lnot (y + \mathcal{Y}(i) \leq m)
\lor \beta_{i, x + x', y + y'}
$$

$$
C_2 :
\lnot \gamma_{i, x, y} \lor \lnot R(i)
\lor \lnot (x + \mathcal{Y}(i) \leq n)
\lor \lnot (y + \mathcal{X}(i) \leq m)
\lor \beta_{i, x + y', y + x'}
$$


\subsection{Minimum d'unités de contact}

Ici aussi, la 5ème règle omise à la question 1 doit être rajoutée pour éviter un rectangle ne soit compté deux fois en touchant un bord.



\subsection{Maximiser le contact}

N'ayant trouvé aucune documentation sur le mode MAX-SAT, nous n'avons pas réussi à l'implémenter.
Nous pouvons cependant modéliser le problème ainsi que spécifier la liste de contraintes à essayer de satisfaire.

\end{document}
